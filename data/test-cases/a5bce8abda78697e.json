{"uid":"a5bce8abda78697e","name":"Create Protocol for bioburden residue verification for non split","fullName":"tests.scenarios.test_multi_prodcution_protocol.TestMultiProductionProtocol#test_create_bioburden_residue_verification_protocol_sqcm_l","historyId":"2172f63081df51a11fa13cbf646c44d8","time":{"start":1709039241598,"stop":1709039247024,"duration":5426},"description":"This test case tests API to Create Protocol bioburden residue verification for split when select based on policy for fungal & bacterial of direct, and  for bacterial & fungal of Indirect when default surface unit is sqcm and volume is L","descriptionHtml":"<p>This test case tests API to Create Protocol bioburden residue verification for split when select based on policy for fungal &amp; bacterial of direct, and  for bacterial &amp; fungal of Indirect when default surface unit is sqcm and volume is L</p>\n","status":"failed","statusMessage":"AssertionError: Direct Swab perUnitAreaAndVolume Values Do Not Match","statusTrace":"self = <test_multi_prodcution_protocol.TestMultiProductionProtocol object at 0x000002CCA3614610>\n\n    @allure.title(\"Create Protocol for bioburden residue verification for non split\")\n    @allure.description(\"This test case tests API to Create Protocol bioburden residue verification for split \"\n                        \"when select based on policy for fungal & bacterial of direct, and  for bacterial & \"\n                        \"fungal of Indirect when default surface unit is sqcm and volume is L\")\n    @allure.link(\"https://app.clickup.com/t/86cuhb2hv\")\n    @pytest.mark.formulation\n    @pytest.mark.create_bioburden_residue_verification_protocol_sqcm_l\n    def test_create_bioburden_residue_verification_protocol_sqcm_l(self):\n        bioburden_data = {}\n        bioburden_data.update(self.DEFAULT_SURFACE_AREA_SQCM)\n        unit = self.update_default_unit.test_get_default_unit(bioburden_data)[\"response\"]\n        unit = json.loads(unit)[\"default_units\"][\"unit\"]\n        bioburden_data.update(self.DEFAULT_VOLUME_L)\n        volume_unit = self.update_default_unit.test_get_default_unit(bioburden_data)[\"response\"]\n        volume_unit = json.loads(volume_unit)[\"default_units\"][\"unit\"]\n    \n        if unit != \"sqcm\" and volume_unit != \"L\":\n            self.update_default_unit.test_update_default_unit(bioburden_data)\n            self.change_assessment.test_start_cleaning_assessment(scenario=True)\n            self.change_assessment.test_submit_approve_cleaning_assessment()\n    \n        columns_prod = [\"production_id\"]\n        productions_list = Excel.read_excel_columns(const.get_master_data(), \"config\", columns_prod)\n        data = {\"production\": productions_list[\"production_id\"], \"description\": \"Automation Protocol\"}\n        protocol_detail, data = self.setup_protocol(data)\n        self.multi_protocol.PROTOCOL = json.loads(protocol_detail)\n        data.update({\"protocol_name\": None})\n        protocol_id = self.multi_protocol.get_protocol_id(data)\n        data.update({\"protocol_id\": protocol_id, \"bioburden_verification\": True})\n        data.update({\"update_verification_protocol\": protocol_verification_payload(data)})\n        get_equipment = self.protocol_equipment.get_equipment_protocol(data)[\"response\"]\n    \n        self.protocol_bioburden.PROTOCOL_EQUIPMENT = json.loads(get_equipment)\n    \n        self.protocol_verification.update_inspection_protocol(data)\n    \n        direct_equipments_sal = \\\n            self.protocol_bioburden.get_bioburden_direct_contact_surface_area_details(data)[\"response\"]\n        self.protocol_bioburden.DIRECT_BIOBURDEN_EQUIPMENT = json.loads(direct_equipments_sal)\n        indirect_equipment_sal = \\\n            self.protocol_bioburden.get_bioburden_indirect_contact_surface_area_details(data)[\"response\"]\n        self.protocol_bioburden.INDIRECT_BIOBURDEN_EQUIPMENT = json.loads(indirect_equipment_sal)\n    \n        direct_equipment = self.protocol_bioburden.direct_update_policy_payload()\n        indirect_equipment = self.protocol_bioburden.indirect_update_policy_payload()\n    \n        data.update({\"direct_equipment\": direct_equipment, \"indirect_equipment\": indirect_equipment,\n                     \"direct_fungal_policy\": \"policyBased\", \"direct_bacterial_policy\": \"policyBased\",\n                     \"indirect_fungal_policy\": \"policyBased\", \"indirect_bacterial_policy\": \"policyBased\"})\n        data.update({\n            \"update_bioburden_residue_verification_payload\": update_bioburden_residue_verification_fungal_bacterial_payload(\n                data)})\n    \n        updated_data = self.protocol_bioburden.update_bioburden_residue_verification_protocol(data)[\"response\"]\n        updated_data = json.loads(updated_data)[\"result\"][\"bioburdenResidueVerification\"]\n>       self.protocol_bioburden.compare_bioburden_limits_split(updated_data, \"direct\", \"fungal\")\n\ntests\\scenarios\\test_multi_prodcution_protocol.py:3204: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <unit.protocols.protocol_bioburden_residue_verification.ProtocolBioburdenAcceptanceCriteria object at 0x000002CCA186B9D0>\ndata = {'direct': {'bacterial': {'equipments': {'54': {'enabled': True, 'perUnitArea': {'unit': 'sqcm', 'value': 8.0000000000...', 'value': 22}, 'perUnitVolume': {'unit': 'ml', 'value': 26}, 'rinseLimit': 34, ...}, ...}, 'policy': 'policyBased'}}}\nresponse_type = 'direct', microbial_type = 'fungal'\n\n    def compare_bioburden_limits_split(self, data, response_type, microbial_type):\n        microbial_policy = self.policy_microbial.test_get_microbial_cleaning_limits_policy()[\"response\"]\n        policy_data = json.loads(microbial_policy)\n    \n        first_response = self.extract_values(policy_data, response_type)\n        second_response = self.get_limits(data, response_type, microbial_type)\n    \n        def extract_microbial_values(response, microbial_type):\n            unclassified_values = response.get('unclassified', {}).get(microbial_type)\n            default_values = response.get('default', {}).get(microbial_type)\n            return unclassified_values or default_values\n    \n        # Extract microbial values from the first response\n        swab_response = first_response.get(f'{response_type.capitalize()} - Swab', {})\n        microbial_swab_first_response = extract_microbial_values(swab_response, microbial_type)\n        per_unit_area_and_volume_first_response = None\n        if microbial_type == \"fungal\":\n            per_unit_area_and_volume_first_response = swab_response.get('unclassified', {}).get(\n                'fungal_per_unit_volume')\n    \n        if microbial_type == \"bacterial\":\n            per_unit_area_and_volume_first_response = swab_response.get('unclassified', {}).get(\n                'bacterial_per_unit_volume')\n    \n        # Extract microbial values from the second response more explicitly\n        second_response_key = list(second_response.keys())[0] if second_response else None\n        microbial_swab_second_response = second_response.get(second_response_key, {}).get('swab_limit', {}).get('value')\n        per_unit_area_and_volume_second_response = second_response.get(second_response_key, {}).get('swab_limit',\n                                                                                                    {}).get(\n            'perUnitArea', {}).get('value')\n    \n        # Compare values with assert statements\n        if microbial_swab_first_response is not None and microbial_swab_second_response is not None:\n            assert microbial_swab_first_response == microbial_swab_second_response, f\"{response_type.capitalize()} Swab {microbial_type.capitalize()} Values Do Not Match\"\n        if per_unit_area_and_volume_first_response is not None and per_unit_area_and_volume_second_response is not None:\n>           assert per_unit_area_and_volume_first_response == per_unit_area_and_volume_second_response, f\"{response_type.capitalize()} Swab perUnitAreaAndVolume Values Do Not Match\"\nE           AssertionError: Direct Swab perUnitAreaAndVolume Values Do Not Match\n\ntests\\unit\\protocols\\protocol_bioburden_residue_verification.py:287: AssertionError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":36,"retriesStatusChange":true,"beforeStages":[{"name":"login","time":{"start":1709038682534,"stop":1709038683052,"duration":518},"status":"passed","steps":[],"attachments":[],"parameters":[],"attachmentsCount":0,"shouldDisplayMessage":false,"hasContent":false,"attachmentStep":false,"stepsCount":0},{"name":"get_facility","time":{"start":1709038683052,"stop":1709038683859,"duration":807},"status":"passed","steps":[],"attachments":[],"parameters":[],"attachmentsCount":0,"shouldDisplayMessage":false,"hasContent":false,"attachmentStep":false,"stepsCount":0}],"afterStages":[],"labels":[{"name":"tag","value":"create_bioburden_residue_verification_protocol_sqcm_l"},{"name":"tag","value":"formulation"},{"name":"tag","value":"multi_production_protocol"},{"name":"tag","value":"scenario"},{"name":"parentSuite","value":"tests.scenarios"},{"name":"suite","value":"test_multi_prodcution_protocol"},{"name":"subSuite","value":"TestMultiProductionProtocol"},{"name":"host","value":"DESKTOP-ESU2KLG"},{"name":"thread","value":"28604-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.scenarios.test_multi_prodcution_protocol"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[{"name":"https://app.clickup.com/t/86cuhb2hv","url":"https://app.clickup.com/t/86cuhb2hv","type":"link"}],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[{"uid":"6fafa958489b0751","status":"failed","statusDetails":"AssertionError: Direct Swab perUnitAreaAndVolume Values Do Not Match","time":{"start":1708873364022,"stop":1708873369835,"duration":5813}},{"uid":"8b118d8e1cd1a32f","status":"failed","statusDetails":"AssertionError: 419","time":{"start":1708872961563,"stop":1708872961563,"duration":0}},{"uid":"366a53f0597796e6","status":"failed","statusDetails":"AssertionError: {\"message\":[[\"username must match /^[\\\\w#.\\\\/-]{1,100}$/ regular expression\"]]}","time":{"start":1708872541522,"stop":1708872541522,"duration":0}},{"uid":"ded7dd8520066a6b","status":"failed","statusDetails":"AssertionError: Direct Swab perUnitAreaAndVolume Values Do Not Match","time":{"start":1708598708719,"stop":1708598714399,"duration":5680}},{"uid":"e74ec3a3ad66e03b","status":"failed","statusDetails":"AssertionError: 419","time":{"start":1708597471190,"stop":1708597471190,"duration":0}},{"uid":"55b012055982c023","status":"failed","statusDetails":"AssertionError: Direct Swab perUnitAreaAndVolume Values Do Not Match","time":{"start":1708596855196,"stop":1708596860889,"duration":5693}},{"uid":"82b26414a01b7ca3","status":"failed","statusDetails":"AssertionError: 419","time":{"start":1708595632819,"stop":1708595632819,"duration":0}},{"uid":"d2a13e4628219f31","status":"failed","statusDetails":"AssertionError: 419","time":{"start":1708595191441,"stop":1708595191441,"duration":0}},{"uid":"ef5013c57500d992","status":"failed","statusDetails":"AssertionError: Direct Swab perUnitAreaAndVolume Values Do Not Match","time":{"start":1708589305441,"stop":1708589306746,"duration":1305}},{"uid":"1533029280aa8a79","status":"failed","statusDetails":"AssertionError: Direct Swab perUnitAreaAndVolume Values Do Not Match","time":{"start":1708587050184,"stop":1708587053761,"duration":3577}},{"uid":"7a8e4dc50bb65cb1","status":"failed","statusDetails":"AssertionError: {\"message\":[[\"username must match /^[\\\\w#.\\\\/-]{1,100}$/ regular expression\"]]}","time":{"start":1708586198044,"stop":1708586198044,"duration":0}},{"uid":"95766ed0d3f371d9","status":"failed","statusDetails":"AssertionError: Direct Swab perUnitAreaAndVolume Values Do Not Match","time":{"start":1708521286702,"stop":1708521289351,"duration":2649}},{"uid":"8105e5db3ed8a75a","status":"failed","statusDetails":"AssertionError: 419","time":{"start":1708520657480,"stop":1708520657480,"duration":0}},{"uid":"edb0dfd4f07b6e09","status":"failed","statusDetails":"AssertionError: 419","time":{"start":1708520580508,"stop":1708520580508,"duration":0}},{"uid":"b7789c7c4189d98e","status":"failed","statusDetails":"AssertionError: Direct Swab perUnitAreaAndVolume Values Do Not Match","time":{"start":1708519631044,"stop":1708519633734,"duration":2690}},{"uid":"f8b2e9d9db445569","status":"failed","statusDetails":"AssertionError: 419","time":{"start":1708519088715,"stop":1708519088715,"duration":0}},{"uid":"2021c0fb5bd3def4","status":"failed","statusDetails":"AssertionError: {\"message\":[[\"username must match /^[\\\\w#.\\\\/-]{1,100}$/ regular expression\"]]}","time":{"start":1708519070961,"stop":1708519070961,"duration":0}},{"uid":"a18e324fc263f9d7","status":"failed","statusDetails":"AssertionError: Direct Swab perUnitAreaAndVolume Values Do Not Match","time":{"start":1708508762232,"stop":1708508763437,"duration":1205}},{"uid":"e68b0f4130587b02","status":"failed","statusDetails":"AssertionError: Direct Swab perUnitAreaAndVolume Values Do Not Match","time":{"start":1708258557433,"stop":1708258559896,"duration":2463}},{"uid":"6ffc0371358add84","status":"failed","statusDetails":"AssertionError: Direct Swab perUnitAreaAndVolume Values Do Not Match","time":{"start":1708246745387,"stop":1708246746635,"duration":1248}},{"uid":"a0f7c6788453d73","status":"failed","statusDetails":"AssertionError: Direct Swab perUnitAreaAndVolume Values Do Not Match","time":{"start":1708241893624,"stop":1708241895293,"duration":1669}},{"uid":"911957e4321f09e","status":"failed","statusDetails":"AssertionError: 419","time":{"start":1708241643906,"stop":1708241643906,"duration":0}},{"uid":"338b0a4ad7211cc2","status":"skipped","statusDetails":"Skipped: test case for Formulation only","time":{"start":1708235045978,"stop":1708235045978,"duration":0}},{"uid":"d3e7d47b4ea16068","status":"skipped","statusDetails":"Skipped: test case for Formulation only","time":{"start":1708232037399,"stop":1708232037399,"duration":0}},{"uid":"f4138c73db43377","status":"skipped","statusDetails":"Skipped: test case for Formulation only","time":{"start":1708231704872,"stop":1708231704872,"duration":0}},{"uid":"a6558ab2d032fb61","status":"skipped","statusDetails":"Skipped: test case for Formulation only","time":{"start":1708231509543,"stop":1708231509543,"duration":0}},{"uid":"c8e83f6decdef8ab","status":"failed","statusDetails":"AssertionError: Direct Swab perUnitAreaAndVolume Values Do Not Match","time":{"start":1707903229512,"stop":1707903231146,"duration":1634}},{"uid":"1748ca74d8a68276","status":"failed","statusDetails":"AssertionError: Direct Swab perUnitAreaAndVolume Values Do Not Match","time":{"start":1707816309345,"stop":1707816311180,"duration":1835}},{"uid":"5de6e0f305241103","status":"failed","statusDetails":"AssertionError: Direct Swab perUnitAreaAndVolume Values Do Not Match","time":{"start":1707801440107,"stop":1707801441704,"duration":1597}},{"uid":"743266873cd076eb","status":"failed","statusDetails":"AssertionError: 419","time":{"start":1707800941551,"stop":1707800941551,"duration":0}},{"uid":"f53e8c38e4d7b18f","status":"failed","statusDetails":"AssertionError: Direct Swab perUnitAreaAndVolume Values Do Not Match","time":{"start":1707800536127,"stop":1707800537934,"duration":1807}},{"uid":"4bea90d15ab87feb","status":"failed","statusDetails":"AssertionError: Direct Swab perUnitAreaAndVolume Values Do Not Match","time":{"start":1707799799582,"stop":1707799801500,"duration":1918}},{"uid":"77b2accc4e22857f","status":"failed","statusDetails":"AssertionError: 419","time":{"start":1707799372332,"stop":1707799372332,"duration":0}},{"uid":"55bea7635b9d73","status":"failed","statusDetails":"AssertionError: 419","time":{"start":1707799327184,"stop":1707799327184,"duration":0}},{"uid":"b3ce7642b80efe09","status":"failed","statusDetails":"AssertionError: {\"message\":[[\"username must match /^[\\\\w#.\\\\/-]{1,100}$/ regular expression\"]]}","time":{"start":1707799308262,"stop":1707799308262,"duration":0}},{"uid":"80972620f2901527","status":"failed","statusDetails":"AssertionError: Direct Swab perUnitAreaAndVolume Values Do Not Match","time":{"start":1707719845304,"stop":1707719846796,"duration":1492}}],"categories":[{"name":"Product defects","matchedStatuses":[],"flaky":false}],"tags":["multi_production_protocol","scenario","formulation","create_bioburden_residue_verification_protocol_sqcm_l"]},"source":"a5bce8abda78697e.json","parameterValues":[]}